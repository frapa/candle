var Kernel_View_Ui_Treerow = Kernel_View_Ui_Row.extend({
    cellTemplate: _.template('<td><%= data %> <span class="count"><%= count %></span></td>'),

    initialize: function (options) {
        this.parent = options.parent;
        this.children = options.children;
        this.childCollection = options.childCollection;
        this.actions = options.actions;

        this.createSubRows(options);
        Kernel_View_Ui_Row.prototype.initialize.call(this, options);
    },

    updateCount: function (newCount) {
        if (newCount) {
            _this.$('.count').first().html('(' + newCount + ')')
        } else {
            // We need to remove the whole subtable
            this.$subRow.remove();

            // Remove count
            _this.$('.count').html('');

            // Finally we need to remove the Unfolding-indicator
            _this.$('.unfold-indicator')
                .removeClass('icon-down-open-mini')
                .removeClass('icon-right-open-mini');
        }

        if ()
    },

    initListenersAfterRender: function () {
        var _this = this;

        this.listenTo(this.childCollection, "add", function (element) {
            //_this.buildTree(_this.renderRows.bind(_this, options.anmgr));
        });

        this.listenTo(this.childCollection, "remove", function (element) {
            var deletedRow = _.find(_this.subRows, function (row) {
                return row.model.get('Id') === element.get('Id');
            });
            deletedRow.remove();

            var newCount = this.childCollection.length;
            _this.updateCount(newCount);
        });
    },

    createSubRows: function (options) {
        var _this = this;
        this.subRows = [];

        _.each(this.children, function (child) {
            var row = new Kernel_View_Ui_Treerow({
                model: child.model,
                children: child.children,
                childCollection: child.childCollection,
                columns: options.columns,
                actions: options.actions,
                parent: _this
            });
            _this.subRows.push(row);
        });
    },

    countChildren: function () {
        return _.reduce(this.subRows, function (partialSum, row) {
            return partialSum + 1 + row.countChildren();
        }, 0);
    },

    /* Actions can be specified with the following object
     *  {
     *      icon: 'icon-plus-squared',
     *      callback: function () {},
     *      tooltip: 'example'
     *  }
     *
     *  The this pointer of the callback is set to the button
     *  element.
     */
    renderActions: function ($cell) {
        var $div = $('<div class="table-actions"></div>');

        var _this = this;
        var $actions = _.map(this.actions, function (action) {
            var $actionButton = $('<span class="table-action"></span>');

            $actionButton.addClass(action.icon);
            $actionButton.click(action.callback.bind({
                $button: $actionButton,
                row: _this,
                rowData: _this.columnData,
                model: _this.model
            }));

            action.tooltip.openOnHover($actionButton);

            return $actionButton;
        });

        $div.append($actions);

        $cell.css('position', 'relative');
        $cell.append($div);
    },

    render: function (level) {
        if (level === undefined) {
            level = 0;
        }

        var _this = this;

        var $cells = _.map(this.columnData, function (cell, i) {
            var count = _this.countChildren();
            if (count && i == 0) {
                _.extendOwn(cell, {count: '(' + count + ')'});
            } else {
                _.extendOwn(cell, {count: ''});
            }

            var $cell = $(_this.cellTemplate(cell));

            if (i == 0) {
                _this.addUnfoldingIndicator($cell, level);
            }

            return $cell;
        });

        var $row = $('<tr></tr>');
        $row.append($cells);

        this.renderActions(_.last($cells));

        this.setElement($row);

        // Add subrows into another subtable
        if (this.subRows.length) {
            this.$subRow = $('<tr class="treeSubRow"><td colspan="' +
                this.columnData.length + '"></td></tr>');
            this.$subTable = $('<table class="table treeSubTable"></table>');

            _.invoke(this.subRows, 'render', level+1);
            var $rows = _.flatten(_.map(this.subRows, function (row) {
                return [row.$el, row.$subRow];
            }), true);

            this.$subTable.append($rows);
            this.$subRow.children().first().append(this.$subTable);
        } else {
            this.$subRow = $([]);
        }

        this.initListenersAfterRender();
        return this;
    },

    addUnfoldingIndicator: function (cell, level) {
        var $indicator = $('<span class="unfold-indicator ' +
            (this.children.length ? 'icon-down-open-mini' : '') + '"></span>')
        
        // This adds margin-left to nest the tree and show it properly
        $indicator.css('margin-left', (level * 1.4) + 'em')

        var _this = this;
        $indicator.click(function () {
            $indicator.toggleClass('icon-down-open-mini icon-right-open-mini');
            _this.$subRow.toggle();
        });

        cell.prepend($indicator);
    }
});
